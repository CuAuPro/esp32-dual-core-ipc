#include <Arduino.h>
#include <freertos/semphr.h> // Include the FreeRTOS semaphore header

TaskHandle_t Task1;
TaskHandle_t Task2;
SemaphoreHandle_t sharedMemorySemaphore;      // Semaphore for shared memory access
SemaphoreHandle_t writePermissionSemaphore;      // Semaphore to synchronize read completion

// Define the size of the shared memory array
const int sharedMemorySize = 10;
float sharedMemory[sharedMemorySize];

// LED pins
const int led1 = 2;
const int led2 = 4;

void Task1code(void *pvParameters);
void Task2code(void *pvParameters);

void setup() {
  Serial.begin(115200);
  pinMode(led1, OUTPUT);
  pinMode(led2, OUTPUT);

  // Create the semaphore for shared memory access
  sharedMemorySemaphore = xSemaphoreCreateMutex();

  // Check if the semaphore was created successfully
  if (sharedMemorySemaphore == NULL) {
    Serial.println("Semaphore creation failed!");
    while (1)
      ; // Stop here if semaphore creation failed
  }

  // Create the semaphore for read completion synchronization
  writePermissionSemaphore = xSemaphoreCreateBinary();

  // Check if the semaphore was created successfully
  if (writePermissionSemaphore == NULL) {
    Serial.println("Semaphore creation failed!");
    while (1)
      ; // Stop here if semaphore creation failed
  }


  xSemaphoreGive(sharedMemorySemaphore); // Task2 can start immediately
  xSemaphoreGive(writePermissionSemaphore); // Give the writePermissionSemaphore initially

  // Create Task1 on core 0
  xTaskCreatePinnedToCore(
    Task1code,   /* Task function. */
    "Task1",     /* name of task. */
    10000,       /* Stack size of task */
    NULL,        /* parameter of the task */
    1,           /* priority of the task */
    &Task1,      /* Task handle to keep track of created task */
    0            /* pin task to core 0 */
  );

  // Create Task2 on core 1
  xTaskCreatePinnedToCore(
    Task2code,   /* Task function. */
    "Task2",     /* name of task. */
    10000,       /* Stack size of task */
    NULL,        /* parameter of the task */
    1,           /* priority of the task */
    &Task2,      /* Task handle to keep track of created task */
    1            /* pin task to core 1 */
  );
}

void Task1code(void *pvParameters) {
  Serial.print("Task1 running on core ");
  Serial.println(xPortGetCoreID());

  for (;;) {
    // Wait for Task2 to finish reading
    xSemaphoreTake(writePermissionSemaphore, portMAX_DELAY);

    // Acquire the semaphore before accessing shared memory
    if (xSemaphoreTake(sharedMemorySemaphore, (TickType_t)portMAX_DELAY) == pdTRUE) {
      // Access and modify the shared memory array
      for (int i = 0; i < sharedMemorySize; i++) {
        sharedMemory[i] += 1.0;
        Serial.print("Task1: sharedMemory[");
        Serial.print(i);
        Serial.print("] = ");
        Serial.println(sharedMemory[i]);
      }

      // Release the semaphore after accessing shared memory
      xSemaphoreGive(sharedMemorySemaphore);
    }
  }
}

void Task2code(void *pvParameters) {
  Serial.print("Task2 running on core ");
  Serial.println(xPortGetCoreID());

  for (;;) {
    // Acquire the semaphore before accessing shared memory
    if (xSemaphoreTake(sharedMemorySemaphore, (TickType_t)portMAX_DELAY) == pdTRUE) {
      // Access the shared memory array
      for (int i = 0; i < sharedMemorySize; i++) {
        sharedMemory[i] -= 1.0;
        Serial.print("Task2: sharedMemory[");
        Serial.print(i);
        Serial.print("] = ");
        Serial.println(sharedMemory[i]);
      }

      // Release the semaphore after accessing shared memory
      xSemaphoreGive(sharedMemorySemaphore);
      // Signal Task1 that reading is complete
      xSemaphoreGive(writePermissionSemaphore);
      vTaskDelay(pdMS_TO_TICKS(1)); // Add a delay to observe the behavior
    }


  }
}

void loop() {}